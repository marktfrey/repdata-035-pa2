---
title: "Public Health and Economic Consequences of Severe Weather Events, 1950-2011"
output:
  html_document:
    keep_md: TRUE
---

## SYNOPSIS

---

## ASSUMPTIONS

Per the information here: https://www.ncdc.noaa.gov/stormevents/details.jsp

The data from 1950 - 1955 contains _only_ information from tornadoes.  The data from 1955-1996 is also limited, but contains potentially useful data.  Post 1996, all of the 48 event types should be present.

---

## RESULTS

---

## DATA PROCESSING

First we download and extract the NOAA storm data.
```{r cache=TRUE}
# Check for data dir
if (!file.exists("data")) {
  dir.create("data")
}

# Check for data source file, download if needed.
if (!file.exists("data/noaa_storm_data.bz2")) {
  download.file("https://d396qusza40orc.cloudfront.net/repdata%2Fdata%2FStormData.csv.bz2", destfile="data/noaa_storm_data.bz2", method="curl")
}

noaa <- read.csv('data/noaa_storm_data.bz2',
                 header = TRUE, stringsAsFactors = FALSE, strip.white=TRUE)
dim(noaa)
```

Also let's grab the documentation from http://www.ncdc.noaa.gov/stormevents/pd01016005curr.pdf.
Linux/Mac package 'xpdf' is required to extract the 48 categories.
```{r}
library(tm)
if (!file.exists("data/pd01016005curr.pdf")) {
  download.file("http://www.ncdc.noaa.gov/stormevents/pd01016005curr.pdf", destfile="data/pd01016005curr.pdf", method="curl")
}

# Read the PDF using `tm`'s `readPDF`.  This requires a pdf engine, I used
# xpdf on a mac.
pdf <- readPDF(control = list(c(text = "-layout")))
pdf <- pdf(elem=list(uri="data/pd01016005curr.pdf"),language="en")

# Extract the 'Event Types' from the table of contents
toc <- paste(pdf$content[78:91], collapse = ' ')

# Then extract the 48 'official' category names.
# We match them based on their format: 7.(1 or two digit number), 
# space, text, space, event designator in parens.
library(stringr)
raw_categories <- str_extract_all(toc, "7\\.[:digit:]+\\.? ([^\\)]*) \\([CMZ]\\)")[[1]]
print(raw_categories)
```

Since we're looking to determine the economic and human impacts of storm events, we should begin by determining how we'll measure each of these and preparing those data.

### Human Impact

For `most harmful with respect to population health`, we'll take a look at both fatalities and injuries.

```{r}
aggregate_fatalities <- aggregate(noaa$FATALITIES, by = list('event_type' = noaa$EVTYPE), sum)
aggregate_fatalities <- aggregate_fatalities[order(aggregate_fatalities$x, decreasing = TRUE), ]
aggregate_fatalities$event_type <- factor(aggregate_fatalities$event_type, levels = aggregate_fatalities[order(aggregate_fatalities$x, decreasing = TRUE), ]$event_type)

head(aggregate_fatalities, 100)

aggregate_injuries   <- aggregate(noaa$INJURIES,   by = list('event_type' = noaa$EVTYPE), sum)
aggregate_injuries <- aggregate_injuries[order(aggregate_injuries$x, decreasing = TRUE), ]
aggregate_injuries$event_type <- factor(aggregate_injuries$event_type, levels = aggregate_injuries[order(aggregate_injuries$x, decreasing = TRUE), ]$event_type)

head(aggregate_injuries, 100)

library(ggplot2)
library(gridExtra)

top100_fatalities <- ggplot(head(aggregate_fatalities, 20), aes(x = event_type, y = x, fill = x)) + geom_bar(stat = 'identity') + scale_fill_gradient2(mid='lightgrey', high='darkred')
top100_injuries <- ggplot(head(aggregate_injuries, 20), aes(x = event_type, y = x, fill = x)) + geom_bar(stat = 'identity') + scale_fill_gradient2(mid='lightgrey', high='darkred')

grid.arrange(top100_fatalities, top100_injuries, ncol=1)
```


### Economic Impact

For economic impact, we'll combine property (`PROPDMG`) and crop (`CROPDMG`) damage into a total dollar value per incident.

In the specification document (https://d396qusza40orc.cloudfront.net/repdata%2Fpeer2_doc%2Fpd01016005curr.pdf, section 2.7) it is indicated that the numeric values of damage estimates are rounded to 3 significant digits, then abbreviated by a magnitude indicator

> Alphabetical characters used to signify magnitude include “K” for thousands, “M” for millions, and “B” for billions.

This magnitude indicator is in the `PROPDMGEXP` and `CROPDMGEXP` variables.  Some of the magnitude indicators don't follow the alpha guidelines, and so we don't know how to normalize them:

```{r cache=TRUE}
# Total nonzero property damage event counts
nonzero_prop_counts <- table(noaa$PROPDMG > 0)
print(nonzero_prop_counts)

# Table of event counts with nonzero property damage and invalid magnitude indicator
invalid_prop_magnitude_counts <- addmargins(table(noaa[noaa$PROPDMG > 0 & !grepl('[kKmMbB ]', noaa$PROPDMGEXP), ]$PROPDMGEXP))
print(invalid_prop_magnitude_counts)

# Percent of events with nonzero property damage that have an invalid magnitude indicator
(invalid_prop_magnitude_counts['Sum'] / nonzero_prop_counts['TRUE']) * 100

# Total nonzero crop damage event counts
nonzero_crop_counts <- table(noaa$CROPDMG > 0)
print(nonzero_crop_counts)

# Table of event counts with nonzero crop damage and invalid magnitude indicator
invalid_crop_magnitude_counts <- addmargins(table(noaa[noaa$CROPDMG > 0 & !grepl('[kKmMbB ]', noaa$CROPDMGEXP), ]$CROPDMGEXP))
print(invalid_crop_magnitude_counts)

# Percent of events with nonzero crop damage that have an invalid magnitude indicator
(invalid_crop_magnitude_counts['Sum'] / nonzero_crop_counts['TRUE']) * 100
```

Since for both variables these comprise a proportionally very small number of incidents (both less than 0.15 percent), we'll simply exclude these incidents from our value calculations.

To normalize the values, we'll decompress and combine the values for property and crop damage, and combine them into a single total dollar value for each incident.

```{r cache = TRUE}
# Populate a column with total economic cost per incident
noaa$economic_cost <- apply(noaa, 1, function(row){
  pval <- as.numeric(row['PROPDMG'])
  if (pval == 0 | !grepl('[kKmMbB ]', row['PROPDMGEXP'])){
    pval <- 0
  } else if (grepl('^[kK]$', row['PROPDMGEXP'])) {
    pval <- pval * 1000
  } else if (grepl('^[mM]$', row['PROPDMGEXP'])) {
    pval <- pval * 1000000
  } else if (grepl('^[bB]$', row['PROPDMGEXP'])) {
    pval <- pval * 1000000000
  }

  cval <- as.numeric(row['CROPDMG'])
  if (cval == 0 | !grepl('[kKmMbB ]', row['CROPDMGEXP'])){
    cval <- 0
  } else if (grepl('^[kK]$', row['CROPDMGEXP'])) {
    cval <- cval * 1000
  } else if (grepl('^[mM]$', row['CROPDMGEXP'])) {
    cval <- cval * 1000000
  } else if (grepl('^[bB]$', row['CROPDMGEXP'])) {
    cval <- cval * 1000000000
  }

  pval + cval
})
```

Now we can aggregate economic cost by event type and compare.
After aggregating, we order the output to be highest aggregate cost to lowest.
We also convert the event type to a factor and force-reorder the levels in the
same arrangement (for plotting purposes).

```{r cache=TRUE}
aggregate_cost <- aggregate(noaa$economic_cost, by = list('event_type' = noaa$EVTYPE), sum)
aggregate_cost <- aggregate_cost[order(aggregate_cost$x, decreasing = TRUE), ]
aggregate_cost$event_type <- factor(aggregate_cost$event_type, levels = aggregate_cost[order(aggregate_cost$x, decreasing = TRUE), ]$event_type)
head(aggregate_cost, 25)
```

Let's take a look at the event types and see if there's a clear cutoff
```{r}
library(ggplot2)
library(gridExtra)

top_25 <- ggplot(head(aggregate_cost, 25), aes(x = event_type, y = x, fill = x)) + geom_bar(stat = 'identity') + scale_fill_gradient2(mid='lightgrey', high='darkred')

print(top_25)
```
